#!/usr/bin/env bash
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#  _   ___  __ _                    
# | \ | \ \/ /| |    ___   __ _ ___ 
# |  \| |\  / | |   / _ \ / _` / __|
# | |\  |/  \ | |__| (_) | (_| \__ \
# |_| \_/_/\_\|_____\___/ \__, |___/
#                         |___/     
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# NX Log Viewer - A beautiful CLI tool for viewing NX monorepo logs
# Version: 1.1.0
# https://github.com/milinbhakta/nx-log-viewer
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

set -e

VERSION="1.1.0"
SCRIPT_NAME="nxlogs"

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Default Configuration
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# Log directory (relative to project root)
LOG_DIR="${LOG_DIR:-logs/nx}"

# Display options
TIMESTAMP="${TIMESTAMP:-true}"
TIMESTAMP_FORMAT="${TIMESTAMP_FORMAT:-%Y-%m-%d %H:%M:%S}"
SHOW_APP_NAME="${SHOW_APP_NAME:-true}"
COLORIZE="${COLORIZE:-true}"
THEME="${THEME:-default}"

# App discovery
AUTO_DISCOVER="${AUTO_DISCOVER:-true}"
APPS="${APPS:-}"
APP_DIRS="${APP_DIRS:-apps packages libs}"

# Defaults
DEFAULT_LINES="${DEFAULT_LINES:-50}"
PAGER="${PAGER:-less -R}"

# Log rotation
ENABLE_ROTATION="${ENABLE_ROTATION:-false}"
MAX_LOG_LINES="${MAX_LOG_LINES:-7000}"
TRIM_TO_LINES="${TRIM_TO_LINES:-5000}"

# Output modes
JSON_OUTPUT="${JSON_OUTPUT:-false}"
EXPORT_FILE="${EXPORT_FILE:-}"
QUIET_MODE="${QUIET_MODE:-false}"

# Pattern matching
HIGHLIGHT_ERRORS="${HIGHLIGHT_ERRORS:-error|exception|failed|fatal|critical}"
HIGHLIGHT_WARNINGS="${HIGHLIGHT_WARNINGS:-warn|warning|deprecated}"
HIGHLIGHT_SUCCESS="${HIGHLIGHT_SUCCESS:-success|completed|ready|started|listening}"
HIGHLIGHT_DEBUG="${HIGHLIGHT_DEBUG:-debug|trace|verbose}"
IGNORE_PATTERNS="${IGNORE_PATTERNS:-}"

# Log file naming
LOG_EXTENSION="${LOG_EXTENSION:-.log}"
# Note: We set the pattern without brace expansion risk
if [[ -z "$LOG_FILE_PATTERN" ]]; then
    LOG_FILE_PATTERN='{app}.log'
fi

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Color Definitions & Themes
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

setup_colors() {
    if [[ "$COLORIZE" != "true" ]] || [[ ! -t 1 ]]; then
        # No colors
        RESET="" BOLD="" DIM=""
        RED="" GREEN="" YELLOW="" BLUE="" MAGENTA="" CYAN="" WHITE="" GRAY=""
        BG_RED="" BG_GREEN="" BG_YELLOW="" BG_BLUE=""
        ERROR_COLOR="" WARN_COLOR="" SUCCESS_COLOR="" DEBUG_COLOR="" INFO_COLOR=""
        HEADER_COLOR="" BORDER_COLOR="" APP_PREFIX_COLOR=""
        return
    fi

    # Basic ANSI codes
    RESET="\033[0m"
    BOLD="\033[1m"
    DIM="\033[2m"
    
    # Apply theme
    case "$THEME" in
        dark)
            # Dark theme - high contrast for dark terminals
            RED="\033[1;91m"
            GREEN="\033[1;92m"
            YELLOW="\033[1;93m"
            BLUE="\033[1;94m"
            MAGENTA="\033[1;95m"
            CYAN="\033[1;96m"
            WHITE="\033[1;97m"
            GRAY="\033[0;37m"
            ERROR_COLOR="\033[1;91m"
            WARN_COLOR="\033[1;93m"
            SUCCESS_COLOR="\033[1;92m"
            DEBUG_COLOR="\033[0;37m"
            INFO_COLOR="\033[1;96m"
            HEADER_COLOR="\033[1;96m"
            BORDER_COLOR="\033[0;90m"
            APP_PREFIX_COLOR="\033[1;95m"
            ;;
        light)
            # Light theme - darker colors for light terminals
            RED="\033[0;31m"
            GREEN="\033[0;32m"
            YELLOW="\033[0;33m"
            BLUE="\033[0;34m"
            MAGENTA="\033[0;35m"
            CYAN="\033[0;36m"
            WHITE="\033[0;30m"
            GRAY="\033[0;90m"
            ERROR_COLOR="\033[0;31m"
            WARN_COLOR="\033[0;33m"
            SUCCESS_COLOR="\033[0;32m"
            DEBUG_COLOR="\033[0;90m"
            INFO_COLOR="\033[0;34m"
            HEADER_COLOR="\033[0;34m"
            BORDER_COLOR="\033[0;90m"
            APP_PREFIX_COLOR="\033[0;35m"
            ;;
        minimal)
            # Minimal theme - subtle colors
            RED="\033[0;31m"
            GREEN="\033[0;32m"
            YELLOW="\033[0;33m"
            BLUE="\033[0;90m"
            MAGENTA="\033[0;90m"
            CYAN="\033[0;90m"
            WHITE="\033[0m"
            GRAY="\033[0;90m"
            ERROR_COLOR="\033[0;31m"
            WARN_COLOR="\033[0;33m"
            SUCCESS_COLOR="\033[0;32m"
            DEBUG_COLOR="\033[0;90m"
            INFO_COLOR="\033[0m"
            HEADER_COLOR="\033[1m"
            BORDER_COLOR="\033[0;90m"
            APP_PREFIX_COLOR="\033[0;90m"
            ;;
        cyberpunk)
            # Cyberpunk theme - neon colors
            RED="\033[1;35m"
            GREEN="\033[1;92m"
            YELLOW="\033[1;93m"
            BLUE="\033[1;94m"
            MAGENTA="\033[1;95m"
            CYAN="\033[1;96m"
            WHITE="\033[1;97m"
            GRAY="\033[0;95m"
            ERROR_COLOR="\033[1;91m"
            WARN_COLOR="\033[1;95m"
            SUCCESS_COLOR="\033[1;92m"
            DEBUG_COLOR="\033[0;95m"
            INFO_COLOR="\033[1;96m"
            HEADER_COLOR="\033[1;95m"
            BORDER_COLOR="\033[0;95m"
            APP_PREFIX_COLOR="\033[1;96m"
            ;;
        *)
            # Default theme
            RED="\033[0;31m"
            GREEN="\033[0;32m"
            YELLOW="\033[0;33m"
            BLUE="\033[0;34m"
            MAGENTA="\033[0;35m"
            CYAN="\033[0;36m"
            WHITE="\033[0;37m"
            GRAY="\033[0;90m"
            ERROR_COLOR="\033[0;31m"
            WARN_COLOR="\033[0;33m"
            SUCCESS_COLOR="\033[0;32m"
            DEBUG_COLOR="\033[0;90m"
            INFO_COLOR="\033[0;36m"
            HEADER_COLOR="\033[0;36m"
            BORDER_COLOR="\033[0;90m"
            APP_PREFIX_COLOR="\033[0;35m"
            ;;
    esac
    
    # Bold variants
    BOLD_RED="\033[1;31m"
    BOLD_GREEN="\033[1;32m"
    BOLD_YELLOW="\033[1;33m"
    BOLD_BLUE="\033[1;34m"
    BOLD_CYAN="\033[1;36m"
    
    # Background colors
    BG_RED="\033[41m"
    BG_GREEN="\033[42m"
    BG_YELLOW="\033[43m"
    BG_BLUE="\033[44m"
}

# App-specific colors for multi-log viewing
declare -a APP_COLOR_PALETTE
APP_COLOR_PALETTE=(
    "\033[0;36m"  # Cyan
    "\033[0;32m"  # Green
    "\033[0;33m"  # Yellow
    "\033[0;35m"  # Magenta
    "\033[0;34m"  # Blue
    "\033[0;31m"  # Red
    "\033[0;37m"  # White
    "\033[0;90m"  # Gray
)

get_app_color() {
    local app="$1"
    local hash=0
    local i
    for (( i=0; i<${#app}; i++ )); do
        hash=$(( (hash + $(printf '%d' "'${app:$i:1}")) % ${#APP_COLOR_PALETTE[@]} ))
    done
    echo "${APP_COLOR_PALETTE[$hash]}"
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Utility Functions
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

log_error() {
    echo -e "${RED}Error:${RESET} $1" >&2
}

log_warn() {
    echo -e "${YELLOW}Warning:${RESET} $1" >&2
}

log_info() {
    echo -e "${CYAN}Info:${RESET} $1"
}

log_success() {
    echo -e "${GREEN}âœ“${RESET} $1"
}

# Find project root (directory containing nx.json)
find_project_root() {
    local dir="$PWD"
    while [[ "$dir" != "/" ]]; do
        if [[ -f "$dir/nx.json" ]]; then
            echo "$dir"
            return 0
        fi
        dir="$(dirname "$dir")"
    done
    return 1
}

# Load configuration from files
load_config() {
    local project_root="$1"
    local config_files=(
        "$project_root/.nxlogsrc"
        "$HOME/.nxlogsrc"
        "$HOME/.config/nxlogs/config"
    )
    
    for config_file in "${config_files[@]}"; do
        if [[ -f "$config_file" ]]; then
            # shellcheck source=/dev/null
            source "$config_file"
        fi
    done
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# App Discovery
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

discover_apps_from_nx() {
    local project_root="$1"
    local apps=()
    
    # Try to get apps from nx.json
    if [[ -f "$project_root/nx.json" ]] && command -v jq &> /dev/null; then
        # Try to read projects from nx.json
        local nx_projects
        nx_projects=$(jq -r '.projects // {} | keys[]' "$project_root/nx.json" 2>/dev/null || true)
        if [[ -n "$nx_projects" ]]; then
            while IFS= read -r app; do
                apps+=("$app")
            done <<< "$nx_projects"
        fi
    fi
    
    # If no apps found via nx.json, scan directories
    if [[ ${#apps[@]} -eq 0 ]]; then
        for app_dir in $APP_DIRS; do
            if [[ -d "$project_root/$app_dir" ]]; then
                for app_path in "$project_root/$app_dir"/*/; do
                    if [[ -d "$app_path" ]]; then
                        local app_name
                        app_name=$(basename "$app_path")
                        # Check if it has a project.json or is a valid project
                        if [[ -f "$app_path/project.json" ]] || [[ -f "$app_path/package.json" ]]; then
                            apps+=("$app_name")
                        fi
                    fi
                done
            fi
        done
    fi
    
    # Return unique sorted apps
    printf '%s\n' "${apps[@]}" | sort -u
}

discover_apps_from_logs() {
    local log_dir="$1"
    local apps=()
    
    if [[ -d "$log_dir" ]]; then
        for log_file in "$log_dir"/*"$LOG_EXTENSION"; do
            if [[ -f "$log_file" ]]; then
                local app_name
                app_name=$(basename "$log_file" "$LOG_EXTENSION")
                apps+=("$app_name")
            fi
        done
    fi
    
    printf '%s\n' "${apps[@]}" | sort -u
}

get_available_apps() {
    local project_root="$1"
    local log_dir="$project_root/$LOG_DIR"
    
    # If APPS is set in config, use that
    if [[ -n "$APPS" ]]; then
        echo "$APPS" | tr ' ' '\n'
        return
    fi
    
    # First try to find apps from log files
    local log_apps
    log_apps=$(discover_apps_from_logs "$log_dir")
    
    if [[ -n "$log_apps" ]]; then
        echo "$log_apps"
        return
    fi
    
    # Fallback to NX discovery
    if [[ "$AUTO_DISCOVER" == "true" ]]; then
        discover_apps_from_nx "$project_root"
    fi
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Log File Operations
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

get_log_file() {
    local project_root="$1"
    local app="$2"
    local log_file="${LOG_FILE_PATTERN//\{app\}/$app}"
    echo "$project_root/$LOG_DIR/$log_file"
}

get_log_stats() {
    local log_file="$1"
    if [[ -f "$log_file" ]]; then
        local lines size modified
        lines=$(wc -l < "$log_file" 2>/dev/null | tr -d ' ' || echo "0")
        size=$(du -h "$log_file" 2>/dev/null | cut -f1 || echo "0")
        modified=$(stat -c %y "$log_file" 2>/dev/null | cut -d'.' -f1 || \
                   stat -f %Sm -t "%Y-%m-%d %H:%M:%S" "$log_file" 2>/dev/null || \
                   echo "unknown")
        echo "$lines|$size|$modified"
    else
        echo "0|0|none"
    fi
}

rotate_log_file() {
    local log_file="$1"
    local max_lines="${2:-$MAX_LOG_LINES}"
    local trim_to="${3:-$TRIM_TO_LINES}"
    
    if [[ ! -f "$log_file" ]]; then
        return 0
    fi
    
    local lines
    lines=$(wc -l < "$log_file" 2>/dev/null | tr -d ' ')
    
    if [[ "$lines" -gt "$max_lines" ]]; then
        local lines_to_remove=$((lines - trim_to))
        log_info "Rotating $log_file: $lines lines -> $trim_to lines (removing $lines_to_remove)"
        
        # Create backup
        cp "$log_file" "$log_file.backup"
        
        # Trim lines from top
        tail -n "$trim_to" "$log_file" > "$log_file.tmp" && mv "$log_file.tmp" "$log_file"
        
        # Remove backup if successful
        rm -f "$log_file.backup"
        
        return 0
    fi
    
    return 1
}

# Parse relative time expressions like "1 hour ago", "2 days ago", etc.
parse_relative_time() {
    local expr="$1"
    local now
    now=$(date +%s)
    
    # Parse expressions like "N unit(s) ago"
    if [[ "$expr" =~ ^([0-9]+)[[:space:]]*(second|minute|hour|day|week|month|year)s?[[:space:]]*(ago)?$ ]]; then
        local amount="${BASH_REMATCH[1]}"
        local unit="${BASH_REMATCH[2]}"
        
        local seconds=0
        case "$unit" in
            second) seconds=$amount ;;
            minute) seconds=$((amount * 60)) ;;
            hour)   seconds=$((amount * 3600)) ;;
            day)    seconds=$((amount * 86400)) ;;
            week)   seconds=$((amount * 604800)) ;;
            month)  seconds=$((amount * 2592000)) ;;
            year)   seconds=$((amount * 31536000)) ;;
        esac
        
        echo $((now - seconds))
        return 0
    fi
    
    # Try to parse as absolute date
    local timestamp
    if timestamp=$(date -d "$expr" +%s 2>/dev/null); then
        echo "$timestamp"
        return 0
    elif timestamp=$(date -j -f "%Y-%m-%d %H:%M:%S" "$expr" +%s 2>/dev/null); then
        echo "$timestamp"
        return 0
    elif timestamp=$(date -j -f "%Y-%m-%d" "$expr" +%s 2>/dev/null); then
        echo "$timestamp"
        return 0
    fi
    
    log_error "Unable to parse time expression: $expr"
    return 1
}

# Extract timestamp from log line (tries common formats)
extract_timestamp() {
    local line="$1"
    
    # ISO 8601: 2025-01-26T10:30:45 or 2025-01-26 10:30:45
    if [[ "$line" =~ ([0-9]{4}-[0-9]{2}-[0-9]{2})[T[:space:]]([0-9]{2}:[0-9]{2}:[0-9]{2}) ]]; then
        local date_part="${BASH_REMATCH[1]}"
        local time_part="${BASH_REMATCH[2]}"
        if timestamp=$(date -d "$date_part $time_part" +%s 2>/dev/null); then
            echo "$timestamp"
            return 0
        elif timestamp=$(date -j -f "%Y-%m-%d %H:%M:%S" "$date_part $time_part" +%s 2>/dev/null); then
            echo "$timestamp"
            return 0
        fi
    fi
    
    # Unix timestamp at start of line
    if [[ "$line" =~ ^([0-9]{10}) ]]; then
        echo "${BASH_REMATCH[1]}"
        return 0
    fi
    
    return 1
}

filter_by_time() {
    local since="$1"
    local until="$2"
    local line
    
    while IFS= read -r line; do
        local ts
        if ts=$(extract_timestamp "$line"); then
            local show=true
            
            if [[ -n "$since" ]] && [[ "$ts" -lt "$since" ]]; then
                show=false
            fi
            
            if [[ -n "$until" ]] && [[ "$ts" -gt "$until" ]]; then
                show=false
            fi
            
            if [[ "$show" == "true" ]]; then
                echo "$line"
            fi
        else
            # If no timestamp found, include the line
            echo "$line"
        fi
    done
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Log Formatting
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

colorize_line() {
    local line="$1"
    local app="$2"
    local app_color="${3:-$RESET}"
    
    # Skip empty lines
    if [[ -z "$line" ]]; then
        echo ""
        return
    fi
    
    # Detect log level and colorize
    local line_lower
    line_lower=$(echo "$line" | tr '[:upper:]' '[:lower:]')
    
    local color="$RESET"
    if [[ "$line_lower" =~ ($HIGHLIGHT_ERRORS) ]]; then
        color="${ERROR_COLOR:-$RED}"
    elif [[ "$line_lower" =~ ($HIGHLIGHT_WARNINGS) ]]; then
        color="${WARN_COLOR:-$YELLOW}"
    elif [[ "$line_lower" =~ ($HIGHLIGHT_SUCCESS) ]]; then
        color="${SUCCESS_COLOR:-$GREEN}"
    elif [[ "$line_lower" =~ ($HIGHLIGHT_DEBUG) ]]; then
        color="${DEBUG_COLOR:-$GRAY}"
    fi
    
    echo -e "${color}${line}${RESET}"
}

# Detect log level from a line
detect_log_level() {
    local line="$1"
    local line_lower
    line_lower=$(echo "$line" | tr '[:upper:]' '[:lower:]')
    
    if [[ "$line_lower" =~ ($HIGHLIGHT_ERRORS) ]]; then
        echo "error"
    elif [[ "$line_lower" =~ ($HIGHLIGHT_WARNINGS) ]]; then
        echo "warning"
    elif [[ "$line_lower" =~ ($HIGHLIGHT_SUCCESS) ]]; then
        echo "success"
    elif [[ "$line_lower" =~ ($HIGHLIGHT_DEBUG) ]]; then
        echo "debug"
    else
        echo "info"
    fi
}

# Format line as JSON
format_line_json() {
    local line="$1"
    local app="$2"
    local timestamp=""
    local level=""
    
    # Try to extract timestamp
    if [[ "$line" =~ ([0-9]{4}-[0-9]{2}-[0-9]{2}[T[:space:]][0-9]{2}:[0-9]{2}:[0-9]{2}) ]]; then
        timestamp="${BASH_REMATCH[1]}"
    fi
    
    # Detect log level
    level=$(detect_log_level "$line")
    
    # Escape special characters for JSON
    local escaped_line
    escaped_line=$(echo "$line" | sed 's/\\/\\\\/g; s/"/\\"/g; s/	/\\t/g' | tr -d '\n\r')
    
    printf '{"app":"%s","level":"%s","timestamp":"%s","message":"%s"}\n' \
        "$app" "$level" "$timestamp" "$escaped_line"
}

# Format output for JSON mode
format_output_json() {
    local app="$1"
    
    while IFS= read -r line || [[ -n "$line" ]]; do
        # Apply ignore patterns
        if [[ -n "$IGNORE_PATTERNS" ]]; then
            if echo "$line" | grep -qiE "$IGNORE_PATTERNS"; then
                continue
            fi
        fi
        
        format_line_json "$line" "$app"
    done
}

format_output() {
    local app="$1"
    local app_color
    app_color=$(get_app_color "$app")
    
    while IFS= read -r line || [[ -n "$line" ]]; do
        # Apply ignore patterns
        if [[ -n "$IGNORE_PATTERNS" ]]; then
            if echo "$line" | grep -qiE "$IGNORE_PATTERNS"; then
                continue
            fi
        fi
        
        colorize_line "$line" "$app" "$app_color"
    done
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Commands
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

print_header() {
    echo -e "${BOLD}${CYAN}"
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘                       ğŸ“‹ NX Log Viewer                            â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo -e "${RESET}"
}

print_version() {
    echo "$SCRIPT_NAME version $VERSION"
}

print_help() {
    cat << EOF
${BOLD}NX Log Viewer${RESET} - Beautiful log viewing for NX monorepos

${BOLD}USAGE${RESET}
    $SCRIPT_NAME [options] [app...]

${BOLD}COMMANDS${RESET}
    (default)           Interactive app selection
    <app>               View logs for specific app(s)
    serve <apps...>     Start app(s) and capture logs to file
    run <target> <apps> Run any target for app(s) and capture logs
    run-many <args...>  Pass arguments directly to nx run-many
    
${BOLD}OPTIONS${RESET}
    -f, --follow        Follow logs in real-time (like tail -f)
    -n, --lines <N>     Number of lines to show (default: $DEFAULT_LINES)
    -a, --all           View all app logs combined
    -s, --search <term> Search for a term in logs
    -e, --errors        Show only errors and warnings
    
    --daemon            View NX daemon logs
    --cache             View NX cache/task runner logs
    
    --since <time>      Show logs since specified time
    --until <time>      Show logs until specified time
    --rotate [app]      Rotate log files (trim old lines)
    --max-lines <N>     Max lines before rotation (default: $MAX_LOG_LINES)
    --trim-to <N>       Trim to N lines after rotation (default: $TRIM_TO_LINES)
    
    --json              Output logs in JSON format (one object per line)
    --export <file>     Export filtered logs to a file (use - for stdout)
    --quiet             Suppress headers and status messages
    
    --stats             Show log file statistics
    --apps              List available apps
    --clean             Remove all log files
    --stop              Stop all running NX processes
    --reset             Stop processes and clean logs
    --init              Create .nxlogsrc config file
    --config            Show current configuration
    --demo [apps]       Generate demo logs for testing
    
    --no-color          Disable colored output
    --theme <name>      Color theme (default, dark, light, minimal, cyberpunk)
    
    -h, --help          Show this help message
    -v, --version       Show version

${BOLD}TIME FILTERING${RESET}
    Time expressions support various formats:
    
    Relative times:
        "1 hour ago", "2 hours ago"
        "30 minutes ago"
        "1 day ago", "7 days ago"
        "1 week ago", "2 weeks ago"
    
    Absolute times:
        "2025-01-26"
        "2025-01-26 10:30:00"
        Any format accepted by 'date -d' (GNU) or 'date -j -f' (BSD)

${BOLD}LOG ROTATION${RESET}
    Automatically trim logs when they exceed a threshold:
    
        $SCRIPT_NAME --rotate              # Rotate all logs
        $SCRIPT_NAME --rotate api          # Rotate specific app
        $SCRIPT_NAME --rotate --max-lines 10000 --trim-to 7000
    
    Configure automatic rotation in .nxlogsrc:
        ENABLE_ROTATION=true
        MAX_LOG_LINES=7000
        TRIM_TO_LINES=5000

${BOLD}OUTPUT FORMATS${RESET}
    Default output is colorized text. Use --json for machine-readable output:
    
        $SCRIPT_NAME api --json            # JSON output
        $SCRIPT_NAME api --json | jq '.level'
        $SCRIPT_NAME api --export logs.txt # Export to file
        $SCRIPT_NAME api --export - --json # JSON to stdout

${BOLD}EXAMPLES${RESET}
    $SCRIPT_NAME                     # Interactive menu
    $SCRIPT_NAME api                 # View api app logs
    $SCRIPT_NAME -f api              # Follow api logs live
    $SCRIPT_NAME -n 100 api web      # Last 100 lines from api and web
    $SCRIPT_NAME -s "error" api      # Search for errors in api
    $SCRIPT_NAME -e -a               # All errors from all apps
    $SCRIPT_NAME --since "1 hour ago" api    # Logs from last hour
    $SCRIPT_NAME --since "2025-01-26" api    # Logs since date
    $SCRIPT_NAME --rotate api        # Rotate api log file
    $SCRIPT_NAME --stats             # Show log statistics
    $SCRIPT_NAME --demo              # Generate demo logs
    $SCRIPT_NAME api --json          # JSON output
    $SCRIPT_NAME --theme cyberpunk   # Use cyberpunk theme

${BOLD}THEMES${RESET}
    default     Standard colors for most terminals
    dark        High contrast for dark terminals
    light       Darker colors for light terminals
    minimal     Subtle, minimal colors
    cyberpunk   Neon colors for style

${BOLD}CONFIGURATION${RESET}
    Create a .nxlogsrc file in your project root or ~/.nxlogsrc
    See: $SCRIPT_NAME --init

${BOLD}MORE INFO${RESET}
    https://github.com/milinbhakta/nx-log-viewer
EOF
}

cmd_list_apps() {
    local project_root="$1"
    local apps
    apps=$(get_available_apps "$project_root")
    
    if [[ -z "$apps" ]]; then
        log_warn "No apps found. Make sure you're in an NX project with log files."
        return 1
    fi
    
    echo -e "${BOLD}Available Apps:${RESET}\n"
    
    while IFS= read -r app; do
        local log_file
        log_file=$(get_log_file "$project_root" "$app")
        local stats
        stats=$(get_log_stats "$log_file")
        IFS='|' read -r lines size modified <<< "$stats"
        
        local app_color
        app_color=$(get_app_color "$app")
        
        if [[ -f "$log_file" ]]; then
            printf "  ${app_color}â—${RESET} %-20s ${GRAY}%6s lines, %6s, %s${RESET}\n" \
                "$app" "$lines" "$size" "$modified"
        else
            printf "  ${GRAY}â—‹ %-20s (no log file)${RESET}\n" "$app"
        fi
    done <<< "$apps"
    
    echo ""
}

cmd_stats() {
    local project_root="$1"
    local log_dir="$project_root/$LOG_DIR"
    
    print_header
    echo -e "${BOLD}Log File Statistics${RESET}"
    echo -e "${GRAY}Directory: $log_dir${RESET}\n"
    
    printf "%-20s %10s %10s %20s\n" "App" "Lines" "Size" "Last Modified"
    printf "%-20s %10s %10s %20s\n" "â”€â”€â”€" "â”€â”€â”€â”€â”€" "â”€â”€â”€â”€" "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    
    local total_lines=0
    local apps
    apps=$(get_available_apps "$project_root")
    
    while IFS= read -r app; do
        [[ -z "$app" ]] && continue
        
        local log_file
        log_file=$(get_log_file "$project_root" "$app")
        local stats
        stats=$(get_log_stats "$log_file")
        IFS='|' read -r lines size modified <<< "$stats"
        
        local app_color
        app_color=$(get_app_color "$app")
        
        if [[ -f "$log_file" ]]; then
            printf "${app_color}%-20s${RESET} %10s %10s %20s\n" "$app" "$lines" "$size" "$modified"
            total_lines=$((total_lines + lines))
        else
            printf "${GRAY}%-20s %10s %10s %20s${RESET}\n" "$app" "-" "-" "no file"
        fi
    done <<< "$apps"
    
    echo ""
    printf "%-20s %10s\n" "â”€â”€â”€" "â”€â”€â”€â”€â”€"
    printf "${BOLD}%-20s %10s${RESET}\n" "TOTAL" "$total_lines"
    echo ""
}

cmd_view() {
    local project_root="$1"
    local app="$2"
    local lines="${3:-$DEFAULT_LINES}"
    local follow="$4"
    local search="$5"
    local errors_only="$6"
    local since="$7"
    local until="$8"
    
    local log_file
    log_file=$(get_log_file "$project_root" "$app")
    
    if [[ ! -f "$log_file" ]]; then
        log_error "Log file not found: $log_file"
        echo -e "${GRAY}Make sure the app is running and logging to this location.${RESET}"
        return 1
    fi
    
    local stats
    stats=$(get_log_stats "$log_file")
    IFS='|' read -r total_lines size modified <<< "$stats"
    
    echo -e "${BOLD}${HEADER_COLOR:-$CYAN}â•â•â• $app â•â•â•${RESET}"
    echo -e "${GRAY}$log_file ($total_lines lines, $size)${RESET}\n"
    
    # Build filter pipeline
    local search_filter=""
    local error_filter=""
    
    # Search filtering
    if [[ -n "$search" ]]; then
        echo -e "${YELLOW}Searching for: '$search'${RESET}\n"
        search_filter="grep -i --color=always '$search'"
    fi
    
    # Error filtering
    if [[ "$errors_only" == "true" ]]; then
        echo -e "${YELLOW}Showing errors and warnings only${RESET}\n"
        local pattern="$HIGHLIGHT_ERRORS|$HIGHLIGHT_WARNINGS"
        error_filter="grep -iE '$pattern'"
    fi
    
    if [[ "$follow" == "true" ]]; then
        # Follow mode with enhanced formatting
        echo -e "${BOLD}Following logs... (Ctrl+C to stop)${RESET}\n"
        echo -e "${BORDER_COLOR:-$GRAY}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${RESET}"
        
        # Build the follow pipeline
        if [[ -n "$search_filter" ]] && [[ -n "$error_filter" ]]; then
            tail -f "$log_file" | eval "$search_filter" | eval "$error_filter" | while IFS= read -r line; do
                format_follow_line "$line" "$app"
            done
        elif [[ -n "$search_filter" ]]; then
            tail -f "$log_file" | eval "$search_filter" | while IFS= read -r line; do
                format_follow_line "$line" "$app"
            done
        elif [[ -n "$error_filter" ]]; then
            tail -f "$log_file" | eval "$error_filter" | while IFS= read -r line; do
                format_follow_line "$line" "$app"
            done
        else
            tail -f "$log_file" | while IFS= read -r line; do
                format_follow_line "$line" "$app"
            done
        fi
    else
        # Non-follow mode
        local content
        
        # Time filtering requires reading full file
        if [[ -n "$since" ]] || [[ -n "$until" ]]; then
            content=$(cat "$log_file" | filter_by_time "$since" "$until" | tail -n "$lines")
        else
            content=$(tail -n "$lines" "$log_file")
        fi
        
        # Apply filters
        if [[ -n "$search_filter" ]]; then
            content=$(echo "$content" | eval "$search_filter" || true)
        fi
        
        if [[ -n "$error_filter" ]]; then
            content=$(echo "$content" | eval "$error_filter" || true)
        fi
        
        # Output with formatting
        echo "$content" | format_output "$app"
    fi
}

# Format a line in follow mode with timestamp prefix
format_follow_line() {
    local line="$1"
    local app="$2"
    
    # Skip empty lines
    [[ -z "$line" ]] && return
    
    # Apply ignore patterns
    if [[ -n "$IGNORE_PATTERNS" ]]; then
        if echo "$line" | grep -qiE "$IGNORE_PATTERNS"; then
            return
        fi
    fi
    
    # Add reception timestamp if enabled
    local prefix=""
    if [[ "$TIMESTAMP" == "true" ]]; then
        local now
        now=$(date +"$TIMESTAMP_FORMAT")
        prefix="${GRAY}[$now]${RESET} "
    fi
    
    # Colorize and output
    local colored_line
    colored_line=$(colorize_line "$line" "$app")
    echo -e "${prefix}${colored_line}"
}

cmd_view_all() {
    local project_root="$1"
    local lines="${2:-$DEFAULT_LINES}"
    local follow="$3"
    local errors_only="$4"
    
    local apps
    apps=$(get_available_apps "$project_root")
    
    local log_files=()
    while IFS= read -r app; do
        [[ -z "$app" ]] && continue
        local log_file
        log_file=$(get_log_file "$project_root" "$app")
        if [[ -f "$log_file" ]]; then
            log_files+=("$log_file")
        fi
    done <<< "$apps"
    
    if [[ ${#log_files[@]} -eq 0 ]]; then
        log_error "No log files found in $project_root/$LOG_DIR"
        return 1
    fi
    
    echo -e "${BOLD}${CYAN}â•â•â• All Apps â•â•â•${RESET}\n"
    
    if [[ "$follow" == "true" ]]; then
        if [[ "$errors_only" == "true" ]]; then
            local pattern="$HIGHLIGHT_ERRORS|$HIGHLIGHT_WARNINGS"
            tail -f "${log_files[@]}" | grep -iE --color=always "$pattern"
        else
            tail -f "${log_files[@]}"
        fi
    else
        for log_file in "${log_files[@]}"; do
            local app
            app=$(basename "$log_file" "$LOG_EXTENSION")
            local app_color
            app_color=$(get_app_color "$app")
            
            if [[ "$errors_only" == "true" ]]; then
                local pattern="$HIGHLIGHT_ERRORS|$HIGHLIGHT_WARNINGS"
                grep -iE "$pattern" "$log_file" 2>/dev/null | \
                    tail -n "$lines" | while IFS= read -r line; do
                        colorize_line "${app_color}[$app]${RESET} $line" "$app"
                    done
            else
                tail -n "$lines" "$log_file" | while IFS= read -r line; do
                    colorize_line "${app_color}[$app]${RESET} $line" "$app"
                done
            fi
        done
    fi
}

cmd_clean() {
    local project_root="$1"
    local log_dir="$project_root/$LOG_DIR"
    local force="$2"
    
    if [[ ! -d "$log_dir" ]]; then
        log_warn "Log directory does not exist: $log_dir"
        return 0
    fi
    
    local count
    count=$(find "$log_dir" -name "*$LOG_EXTENSION" -type f 2>/dev/null | wc -l | tr -d ' ')
    
    if [[ "$count" -eq 0 ]]; then
        log_info "No log files to clean"
        return 0
    fi
    
    if [[ "$force" != "true" ]]; then
        echo -e "${YELLOW}This will delete $count log file(s) in $log_dir${RESET}"
        read -p "Are you sure? [y/N] " -n 1 -r
        echo ""
        
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            echo "Cancelled"
            return 0
        fi
    fi

    rm -f "$log_dir"/*"$LOG_EXTENSION"
    log_success "Cleaned $count log file(s)"
}

cmd_stop() {
    echo -e "${BOLD}${CYAN}â•â•â• Stopping NX Processes â•â•â•${RESET}"
    
    local pids=""
    if command -v pgrep &> /dev/null; then
        # Match 'nx serve', 'nx run', 'nx run-many'
        # We exclude 'nxlogs' to avoid killing ourselves if possible
        pids=$(pgrep -f "nx (serve|run|run-many)" | grep -v "$$" || true)
    fi
    
    if [[ -n "$pids" ]]; then
        echo -e "${YELLOW}Found running NX processes:${RESET}"
        # Show details (cross-platform ps is tricky, keeping it simple)
        ps -p $pids 2>/dev/null || echo "$pids"
        
        read -p "Kill these processes? [y/N] " -n 1 -r
        echo ""
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            echo "$pids" | xargs kill 2>/dev/null || true
            log_success "Stopped processes"
        else
            echo "Cancelled"
        fi
    else
        log_info "No running NX server processes found"
    fi
}

cmd_reset() {
    local project_root="$1"
    cmd_stop
    cmd_clean "$project_root" "false"
}

cmd_rotate() {
    local project_root="$1"
    local app="${2:-all}"
    local max_lines="${3:-$MAX_LOG_LINES}"
    local trim_to="${4:-$TRIM_TO_LINES}"
    
    if [[ "$app" == "all" ]]; then
        local apps
        apps=$(get_available_apps "$project_root")
        local rotated=0
        
        while IFS= read -r current_app; do
            [[ -z "$current_app" ]] && continue
            local log_file
            log_file=$(get_log_file "$project_root" "$current_app")
            if rotate_log_file "$log_file" "$max_lines" "$trim_to"; then
                ((rotated++))
            fi
        done <<< "$apps"
        
        if [[ $rotated -gt 0 ]]; then
            log_success "Rotated $rotated log file(s)"
        else
            log_info "No log files needed rotation"
        fi
    else
        local log_file
        log_file=$(get_log_file "$project_root" "$app")
        if rotate_log_file "$log_file" "$max_lines" "$trim_to"; then
            log_success "Rotated log file: $log_file"
        else
            log_info "Log file does not need rotation ($(wc -l < "$log_file" 2>/dev/null || echo 0) lines)"
        fi
    fi
}

cmd_init() {
    local project_root="$1"
    local config_file="$project_root/.nxlogsrc"
    
    if [[ -f "$config_file" ]]; then
        log_warn "Config file already exists: $config_file"
        read -p "Overwrite? [y/N] " -n 1 -r
        echo ""
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            echo "Cancelled"
            return 0
        fi
    fi
    
    # Find the example config
    local script_dir
    script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    local example_config="$script_dir/../.nxlogsrc.example"
    
    if [[ -f "$example_config" ]]; then
        cp "$example_config" "$config_file"
    else
        # Inline default config
        cat > "$config_file" << 'DEFAULTCONFIG'
# NX Log Viewer Configuration
LOG_DIR="logs/nx"
TIMESTAMP=true
TIMESTAMP_FORMAT="%Y-%m-%d %H:%M:%S"
SHOW_APP_NAME=true
COLORIZE=true
DEFAULT_LINES=50
AUTO_DISCOVER=true
DEFAULTCONFIG
    fi
    
    log_success "Created config file: $config_file"
}

cmd_show_config() {
    local project_root="$1"
    
    echo -e "${BOLD}Current Configuration${RESET}\n"
    
    echo -e "${CYAN}Log Settings:${RESET}"
    echo "  LOG_DIR=$LOG_DIR"
    echo "  LOG_EXTENSION=$LOG_EXTENSION"
    echo ""
    
    echo -e "${CYAN}Rotation Settings:${RESET}"
    echo "  ENABLE_ROTATION=$ENABLE_ROTATION"
    echo "  MAX_LOG_LINES=$MAX_LOG_LINES"
    echo "  TRIM_TO_LINES=$TRIM_TO_LINES"
    echo ""
    
    echo -e "${CYAN}Display Settings:${RESET}"
    echo "  TIMESTAMP=$TIMESTAMP"
    echo "  TIMESTAMP_FORMAT=$TIMESTAMP_FORMAT"
    echo "  SHOW_APP_NAME=$SHOW_APP_NAME"
    echo "  COLORIZE=$COLORIZE"
    echo "  THEME=$THEME"
    echo "  DEFAULT_LINES=$DEFAULT_LINES"
    echo ""
    
    echo -e "${CYAN}App Discovery:${RESET}"
    echo "  AUTO_DISCOVER=$AUTO_DISCOVER"
    echo "  APP_DIRS=$APP_DIRS"
    [[ -n "$APPS" ]] && echo "  APPS=$APPS"
    echo ""
    
    echo -e "${CYAN}Config Files:${RESET}"
    local config_files=(
        "$project_root/.nxlogsrc"
        "$HOME/.nxlogsrc"
        "$HOME/.config/nxlogs/config"
    )
    for cf in "${config_files[@]}"; do
        if [[ -f "$cf" ]]; then
            echo -e "  ${GREEN}âœ“${RESET} $cf"
        else
            echo -e "  ${GRAY}â—‹ $cf${RESET}"
        fi
    done
    echo ""
}

cmd_interactive() {
    local project_root="$1"
    
    print_header
    
    local apps
    apps=$(get_available_apps "$project_root")
    
    if [[ -z "$apps" ]]; then
        log_warn "No apps found. Make sure you're in an NX project."
        echo ""
        echo "Tips:"
        echo "  - Run your apps first to generate log files"
        echo "  - Check LOG_DIR setting: $LOG_DIR"
        echo "  - Run: $SCRIPT_NAME --init to create a config file"
        echo "  - Run: $SCRIPT_NAME --demo to generate sample logs for testing"
        return 1
    fi
    
    echo -e "${BOLD}Select an app to view logs:${RESET}\n"
    
    local apps_array=()
    local i=1
    
    while IFS= read -r app; do
        [[ -z "$app" ]] && continue
        apps_array+=("$app")
        
        local log_file
        log_file=$(get_log_file "$project_root" "$app")
        local stats
        stats=$(get_log_stats "$log_file")
        IFS='|' read -r lines size modified <<< "$stats"
        
        local app_color
        app_color=$(get_app_color "$app")
        
        if [[ -f "$log_file" ]]; then
            printf "  ${BOLD}%2d)${RESET} ${app_color}%-18s${RESET} ${GRAY}%6s lines, %s${RESET}\n" \
                "$i" "$app" "$lines" "$modified"
        else
            printf "  ${BOLD}%2d)${RESET} ${GRAY}%-18s (no log file)${RESET}\n" "$i" "$app"
        fi
        ((i++))
    done <<< "$apps"
    
    echo ""
    echo -e "  ${BOLD} a)${RESET} View all logs combined"
    echo -e "  ${BOLD} f)${RESET} Follow all logs (live)"
    echo -e "  ${BOLD} e)${RESET} Show errors only"
    echo -e "  ${BOLD} s)${RESET} Show statistics"
    echo -e "  ${BOLD} q)${RESET} Quit"
    echo ""
    
    read -p "Enter choice: " choice
    
    case "$choice" in
        [0-9]*)
            if [[ "$choice" -ge 1 ]] && [[ "$choice" -le ${#apps_array[@]} ]]; then
                local selected_app="${apps_array[$((choice-1))]}"
                cmd_view "$project_root" "$selected_app" "$DEFAULT_LINES" "false" "" "false"
            else
                log_error "Invalid selection"
                return 1
            fi
            ;;
        a|A)
            cmd_view_all "$project_root" "$DEFAULT_LINES" "false" "false"
            ;;
        f|F)
            cmd_view_all "$project_root" "$DEFAULT_LINES" "true" "false"
            ;;
        e|E)
            cmd_view_all "$project_root" "$DEFAULT_LINES" "false" "true"
            ;;
        s|S)
            cmd_stats "$project_root"
            ;;
        q|Q)
            echo "Goodbye!"
            exit 0
            ;;
        *)
            log_error "Invalid choice"
            return 1
            ;;
    esac
}

cmd_demo() {
    local project_root="$1"
    local apps="${2:-api web worker}"
    local log_dir="$project_root/$LOG_DIR"
    
    echo -e "${BOLD}${CYAN}â•â•â• Generating Demo Logs â•â•â•${RESET}\n"
    
    # Create log directory
    mkdir -p "$log_dir"
    
    local demo_apps=($apps)
    local log_levels=("INFO" "DEBUG" "WARN" "ERROR" "SUCCESS")
    local messages=(
        "Application started successfully"
        "Processing request from client"
        "Database connection established"
        "Cache hit for key: user_session_12345"
        "Fetching data from external API"
        "Request completed in 142ms"
        "WebSocket connection opened"
        "Background job started: email_notifications"
        "Memory usage: 256MB / 512MB"
        "Health check passed"
        "User authenticated: user@example.com"
        "File uploaded: document.pdf (2.4MB)"
        "Queue processed: 47 messages"
        "Scheduled task executed: cleanup_temp"
        "Configuration reloaded"
    )
    local warnings=(
        "High memory usage detected (85%)"
        "Deprecated API endpoint called: /v1/legacy"
        "Slow query detected (took 3.2s)"
        "Rate limit approaching for client IP"
        "Certificate expires in 30 days"
        "Connection pool running low"
    )
    local errors=(
        "Failed to connect to database: connection timeout"
        "Unhandled exception in request handler"
        "Authentication failed for user: invalid token"
        "File not found: /tmp/missing.txt"
        "External API returned 503 Service Unavailable"
        "Critical: Disk space below 10%"
    )
    local success=(
        "Build completed successfully"
        "All tests passed (47/47)"
        "Deployment finished"
        "Migration completed"
        "Backup created successfully"
    )
    
    for app in "${demo_apps[@]}"; do
        local log_file="$log_dir/${app}.log"
        echo -e "${CYAN}Creating:${RESET} $log_file"
        
        # Clear existing demo log
        > "$log_file"
        
        # Generate 100 log entries per app
        for i in {1..100}; do
            local timestamp
            # Random time within last 24 hours
            local random_hours=$((RANDOM % 24))
            local random_mins=$((RANDOM % 60))
            local random_secs=$((RANDOM % 60))
            timestamp=$(date -d "$random_hours hours ago" +"%Y-%m-%d %H:%M:%S" 2>/dev/null || \
                        date -v-${random_hours}H +"%Y-%m-%d %H:%M:%S" 2>/dev/null || \
                        date +"%Y-%m-%d %H:%M:%S")
            
            local level=""
            local message=""
            local rand=$((RANDOM % 100))
            
            if [[ $rand -lt 60 ]]; then
                level="INFO"
                message="${messages[$((RANDOM % ${#messages[@]}))]}"
            elif [[ $rand -lt 75 ]]; then
                level="DEBUG"
                message="${messages[$((RANDOM % ${#messages[@]}))]}"
            elif [[ $rand -lt 88 ]]; then
                level="WARN"
                message="${warnings[$((RANDOM % ${#warnings[@]}))]}"
            elif [[ $rand -lt 95 ]]; then
                level="ERROR"
                message="${errors[$((RANDOM % ${#errors[@]}))]}"
            else
                level="SUCCESS"
                message="${success[$((RANDOM % ${#success[@]}))]}"
            fi
            
            echo "[$timestamp] [$level] [$app] $message" >> "$log_file"
        done
        
        # Sort by timestamp
        sort -t'[' -k2 "$log_file" -o "$log_file"
        
        local stats
        stats=$(get_log_stats "$log_file")
        IFS='|' read -r lines size modified <<< "$stats"
        echo -e "  ${GREEN}âœ“${RESET} Generated $lines lines ($size)"
    done
    
    echo ""
    log_success "Demo logs created! Run: $SCRIPT_NAME --stats"
    echo ""
}

cmd_export() {
    local project_root="$1"
    local app="$2"
    local output_file="$3"
    local lines="${4:-0}"  # 0 means all lines
    local search="$5"
    local errors_only="$6"
    local since="$7"
    local until="$8"
    local format="${9:-text}"  # text or json
    
    local log_file
    log_file=$(get_log_file "$project_root" "$app")
    
    if [[ ! -f "$log_file" ]]; then
        log_error "Log file not found: $log_file"
        return 1
    fi
    
    # Determine output destination
    local output_stream
    if [[ "$output_file" == "-" ]]; then
        output_stream="/dev/stdout"
    else
        output_stream="$output_file"
        # Create directory if needed
        mkdir -p "$(dirname "$output_file")"
    fi
    
    {
        local content=""
        
        # Read all or last N lines
        if [[ "$lines" -eq 0 ]]; then
            content=$(cat "$log_file")
        else
            content=$(tail -n "$lines" "$log_file")
        fi
        
        # Apply time filter
        if [[ -n "$since" ]] || [[ -n "$until" ]]; then
            content=$(echo "$content" | filter_by_time "$since" "$until")
        fi
        
        # Apply search filter
        if [[ -n "$search" ]]; then
            content=$(echo "$content" | grep -i "$search" || true)
        fi
        
        # Apply error filter
        if [[ "$errors_only" == "true" ]]; then
            local pattern="$HIGHLIGHT_ERRORS|$HIGHLIGHT_WARNINGS"
            content=$(echo "$content" | grep -iE "$pattern" || true)
        fi
        
        # Apply ignore patterns
        if [[ -n "$IGNORE_PATTERNS" ]]; then
            content=$(echo "$content" | grep -viE "$IGNORE_PATTERNS" || true)
        fi
        
        # Format output
        if [[ "$format" == "json" ]]; then
            echo "$content" | while IFS= read -r line; do
                [[ -n "$line" ]] && format_line_json "$line" "$app"
            done
        else
            echo "$content"
        fi
    } > "$output_stream"
    
    if [[ "$output_file" != "-" ]]; then
        local export_stats
        export_stats=$(get_log_stats "$output_file")
        IFS='|' read -r exported_lines exported_size _ <<< "$export_stats"
        log_success "Exported $exported_lines lines to: $output_file ($exported_size)"
    fi
}

cmd_view_json() {
    local project_root="$1"
    local app="$2"
    local lines="${3:-$DEFAULT_LINES}"
    local search="$4"
    local errors_only="$5"
    local since="$6"
    local until="$7"
    
    local log_file
    log_file=$(get_log_file "$project_root" "$app")
    
    if [[ ! -f "$log_file" ]]; then
        echo '{"error":"Log file not found","file":"'"$log_file"'"}' >&2
        return 1
    fi
    
    # Build the pipeline
    local content
    content=$(tail -n "$lines" "$log_file")
    
    # Apply time filter
    if [[ -n "$since" ]] || [[ -n "$until" ]]; then
        content=$(echo "$content" | filter_by_time "$since" "$until")
    fi
    
    # Apply search filter
    if [[ -n "$search" ]]; then
        content=$(echo "$content" | grep -i "$search" || true)
    fi
    
    # Apply error filter
    if [[ "$errors_only" == "true" ]]; then
        local pattern="$HIGHLIGHT_ERRORS|$HIGHLIGHT_WARNINGS"
        content=$(echo "$content" | grep -iE "$pattern" || true)
    fi
    
    # Apply ignore patterns
    if [[ -n "$IGNORE_PATTERNS" ]]; then
        content=$(echo "$content" | grep -viE "$IGNORE_PATTERNS" || true)
    fi
    
    # Output as JSON (one object per line for streaming)
    echo "$content" | while IFS= read -r line; do
        [[ -n "$line" ]] && format_line_json "$line" "$app"
    done
}

process_multiplexed_logs() {
    local project_root="$1"
    local log_dir="$project_root/$LOG_DIR"
    
    mkdir -p "$log_dir"
    
    # Define ESC for ANSI stripping (portable)
    local esc
    esc=$(printf '\033')
    
    while IFS= read -r line; do
        # Strip CR for Windows compatibility
        line="${line//$'\r'/}"
        
        # Strip ANSI codes using bash substitution
        # This removes color codes and line clearing sequences
        local clean_line="${line//${esc}\[[0-9;]*[mK]/}"
        
        local app_name=""
        
        # Match [app] prefix
        # Supports: [app], [org/app], [app-name], [app_name], [app.name]
        # We allow leading non-alphanumeric chars to handle potential leftover control codes
        if [[ "$clean_line" =~ ^[^a-zA-Z0-9]*\[[[:space:]]*([@a-zA-Z0-9_./-]+)[[:space:]]*\] ]]; then
            app_name="${BASH_REMATCH[1]}"
        elif [[ "$clean_line" =~ ^\>[\ ]*nx[\ ]*run[\ ]*([^:]+): ]]; then
             app_name="${BASH_REMATCH[1]}"
        fi
        
        if [[ -n "$app_name" ]]; then
            # Trim whitespace from app_name
            app_name="${app_name#"${app_name%%[![:space:]]*}"}"
            app_name="${app_name%"${app_name##*[![:space:]]}"}"
            
            local log_file
            log_file=$(get_log_file "$project_root" "$app_name")
            # Ensure dir exists
            mkdir -p "$(dirname "$log_file")"
            echo "$line" >> "$log_file"
            
            # Format for display
            format_follow_line "$line" "$app_name"
        else
            # No app detected
            # Write to a combined log file so we don't lose data if regex fails
            echo "$line" >> "$log_dir/_combined.log"
            
            # Just print to stdout
            echo "$line"
        fi
    done
}

cmd_run_many() {
    local project_root="$1"
    shift
    local args=("$@")
    
    echo -e "${BOLD}${CYAN}â•â•â• Running run-many â•â•â•${RESET}"
    echo -e "${GRAY}Logs will be written to individual app log files in $project_root/$LOG_DIR${RESET}\n"
    
    local nx_cmd="nx"
    if ! command -v nx &> /dev/null; then nx_cmd="npx nx"; fi
    
    # Force stream output to ensure we get [app] prefixes
    # Set NX_INTERACTIVE=false to prevent spinner/dynamic output issues
    # Set NX_DAEMON=false to avoid daemon communication issues in some envs
    NX_DAEMON=false NX_INTERACTIVE=false $nx_cmd run-many --output-style=stream "${args[@]}" 2>&1 | process_multiplexed_logs "$project_root"
}

cmd_run() {
    local project_root="$1"
    local target="$2"
    shift 2
    
    local apps=()
    local args=()
    
    # Parse apps and args
    while [[ $# -gt 0 ]]; do
        if [[ "$1" == -* ]]; then
            args+=("$@")
            break
        else
            apps+=("$1")
            shift
        fi
    done
    
    if [[ ${#apps[@]} -eq 0 ]]; then
        log_error "Please specify at least one app"
        return 1
    fi
    
    echo -e "${BOLD}${CYAN}â•â•â• Running target '$target' for ${#apps[@]} app(s) â•â•â•${RESET}"
    
    local nx_cmd="nx"
    if ! command -v nx &> /dev/null; then nx_cmd="npx nx"; fi
    
    # Create log directory
    local log_dir="$project_root/$LOG_DIR"
    mkdir -p "$log_dir"
    
    echo -e "${GRAY}Logs will be written to: $log_dir${RESET}\n"
    
    # Trap to kill background processes on exit/interrupt
    trap 'kill $(jobs -p) 2>/dev/null' EXIT SIGINT SIGTERM
    
    for app in "${apps[@]}"; do
        local log_file
        log_file=$(get_log_file "$project_root" "$app")
        mkdir -p "$(dirname "$log_file")"
        
        # Clear existing log file
        > "$log_file"
        
        echo -e "${GREEN}Starting $app${RESET} â†’ $log_file"
        
        # Run in background with individual log capturing
        # We use NX_DAEMON=false and NX_INTERACTIVE=false for robustness
        ( 
            NX_DAEMON=false NX_INTERACTIVE=false $nx_cmd run "$app:$target" --output-style=stream "${args[@]}" 2>&1 \
            | tee "$log_file" \
            | while IFS= read -r line; do format_follow_line "$line" "$app"; done 
        ) &
    done
    
    echo ""
    echo -e "${BOLD}âœ… All apps starting... Output streaming below (Ctrl+C to stop all)${RESET}"
    echo -e "${BORDER_COLOR:-$GRAY}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${RESET}"
    
    # Wait for all background processes
    wait
}

cmd_serve() {
    local project_root="$1"
    shift
    cmd_run "$project_root" "serve" "$@"
}

cmd_daemon() {
    local project_root="$1"
    local follow="$2"
    local lines="${3:-$DEFAULT_LINES}"
    
    local daemon_log="$project_root/.nx/daemon.log"
    
    # Try common locations if not found
    if [[ ! -f "$daemon_log" ]]; then
        # Check for global daemon log (macOS/Linux)
        if [[ -f "/tmp/nx-daemon.log" ]]; then
            daemon_log="/tmp/nx-daemon.log"
        elif [[ -f "$HOME/.nx/cache/daemon.log" ]]; then
            daemon_log="$HOME/.nx/cache/daemon.log"
        fi
    fi
    
    if [[ ! -f "$daemon_log" ]]; then
        log_error "NX Daemon log not found"
        return 1
    fi
    
    echo -e "${BOLD}${CYAN}â•â•â• NX Daemon Logs â•â•â•${RESET}"
    echo -e "${GRAY}$daemon_log${RESET}\n"
    
    if [[ "$follow" == "true" ]]; then
        tail -f "$daemon_log" | while IFS= read -r line; do
            colorize_line "$line" "daemon" "${GRAY}"
        done
    else
        tail -n "$lines" "$daemon_log" | while IFS= read -r line; do
            colorize_line "$line" "daemon" "${GRAY}"
        done
    fi
}

cmd_cache() {
    local project_root="$1"
    local follow="$2"
    local lines="${3:-$DEFAULT_LINES}"
    
    # Look for cache logs or task runner logs
    # This is tricky as NX structure varies, but we'll check common spots
    local cache_dir="$project_root/.nx/cache"
    
    if [[ ! -d "$cache_dir" ]]; then
        log_error "NX Cache directory not found: $cache_dir"
        return 1
    fi
    
    echo -e "${BOLD}${CYAN}â•â•â• NX Cache/Task Logs â•â•â•${RESET}"
    echo -e "${GRAY}Listing recent task logs in $cache_dir${RESET}\n"
    
    # Find most recent terminal-outputs
    find "$cache_dir" -name "terminal-output" -type f -print0 | xargs -0 ls -lt | head -n 5 | while read -r line; do
        local file
        file=$(echo "$line" | awk '{print $9}')
        local hash
        hash=$(basename "$(dirname "$file")")
        echo -e "${BOLD}Task Hash: $hash${RESET}"
        cat "$file"
        echo -e "${GRAY}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${RESET}"
    done
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Main
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

main() {
    # Parse arguments
    local cmd=""
    local apps=()
    local follow="false"
    local lines="$DEFAULT_LINES"
    local search=""
    local errors_only="false"
    local view_all="false"
    local since=""
    local until=""
    local rotate_app=""
    local max_lines="$MAX_LOG_LINES"
    local trim_to="$TRIM_TO_LINES"
    local json_output="false"
    local export_file=""
    local quiet="false"
    local demo_apps=""
    
    # Check for 'serve' or 'run' command first as they consume remaining args
    if [[ "$1" == "serve" ]]; then
        cmd="serve"
        shift
        # Collect apps until we hit a flag or --
        local serve_apps=()
        local serve_args=()
        local use_all="false"
        
        while [[ $# -gt 0 ]]; do
            if [[ "$1" == "--all" ]]; then
                use_all="true"
                shift
            elif [[ "$1" == -* ]]; then
                serve_args+=("$@")
                break
            else
                serve_apps+=("$1")
                shift
            fi
        done
        
        # Setup colors and config before running
        setup_colors
        if ! project_root=$(find_project_root); then
            log_error "Not in an NX workspace"
            exit 1
        fi
        load_config "$project_root"
        
        if [[ "$use_all" == "true" ]]; then
            # Fetch all apps
            local all_apps
            all_apps=$(get_available_apps "$project_root")
            if [[ -n "$all_apps" ]]; then
                while IFS= read -r app; do
                    [[ -n "$app" ]] && serve_apps+=("$app")
                done <<< "$all_apps"
            fi
        fi
        
        cmd_serve "$project_root" "${serve_apps[@]}" "${serve_args[@]}"
        exit $?
    elif [[ "$1" == "run" ]]; then
        cmd="run"
        shift
        local target="$1"
        shift
        # Collect apps until we hit a flag or --
        local run_apps=()
        local run_args=()
        local use_all="false"
        
        while [[ $# -gt 0 ]]; do
            if [[ "$1" == "--all" ]]; then
                use_all="true"
                shift
            elif [[ "$1" == -* ]]; then
                run_args+=("$@")
                break
            else
                run_apps+=("$1")
                shift
            fi
        done
        
        # Setup colors and config before running
        setup_colors
        if ! project_root=$(find_project_root); then
            log_error "Not in an NX workspace"
            exit 1
        fi
        load_config "$project_root"
        
        if [[ "$use_all" == "true" ]]; then
            # Fetch all apps
            local all_apps
            all_apps=$(get_available_apps "$project_root")
            if [[ -n "$all_apps" ]]; then
                while IFS= read -r app; do
                    [[ -n "$app" ]] && run_apps+=("$app")
                done <<< "$all_apps"
            fi
        fi
        
        cmd_run "$project_root" "$target" "${run_apps[@]}" "${run_args[@]}"
        exit $?
    elif [[ "$1" == "run-many" ]]; then
        cmd="run-many"
        shift
        local args=("$@")
        
        # Setup colors and config before running
        setup_colors
        if ! project_root=$(find_project_root); then
            log_error "Not in an NX workspace"
            exit 1
        fi
        load_config "$project_root"
        
        cmd_run_many "$project_root" "${args[@]}"
        exit $?
    fi
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                print_help
                exit 0
                ;;
            -v|--version)
                print_version
                exit 0
                ;;
            -f|--follow)
                follow="true"
                shift
                ;;
            -n|--lines)
                lines="$2"
                shift 2
                ;;
            -a|--all)
                view_all="true"
                shift
                ;;
            -s|--search)
                search="$2"
                shift 2
                ;;
            -e|--errors)
                errors_only="true"
                shift
                ;;
            --daemon)
                cmd="daemon"
                shift
                ;;
            --cache)
                cmd="cache"
                shift
                ;;
            --since)
                if ! since=$(parse_relative_time "$2"); then
                    exit 1
                fi
                shift 2
                ;;
            --until)
                if ! until=$(parse_relative_time "$2"); then
                    exit 1
                fi
                shift 2
                ;;
            --rotate)
                cmd="rotate"
                rotate_app="${2:-all}"
                shift
                [[ "$rotate_app" != -* ]] && shift
                ;;
            --max-lines)
                max_lines="$2"
                shift 2
                ;;
            --trim-to)
                trim_to="$2"
                shift 2
                ;;
            --json)
                json_output="true"
                COLORIZE="false"
                shift
                ;;
            --export)
                export_file="$2"
                shift 2
                ;;
            --quiet|-q)
                quiet="true"
                shift
                ;;
            --demo)
                cmd="demo"
                if [[ -n "$2" ]] && [[ "$2" != -* ]]; then
                    demo_apps="$2"
                    shift
                fi
                shift
                ;;
            --stats)
                cmd="stats"
                shift
                ;;
            --apps)
                cmd="apps"
                shift
                ;;
            --clean)
                cmd="clean"
                shift
                ;;
            --stop)
                cmd="stop"
                shift
                ;;
            --reset)
                cmd="reset"
                shift
                ;;
            --init)
                cmd="init"
                shift
                ;;
            --config)
                cmd="config"
                shift
                ;;
            --no-color)
                COLORIZE="false"
                shift
                ;;
            --theme)
                THEME="$2"
                shift 2
                ;;
            -*)
                log_error "Unknown option: $1"
                echo "Use --help for usage information"
                exit 1
                ;;
            *)
                apps+=("$1")
                shift
                ;;
        esac
    done
    
    # Setup colors
    setup_colors
    
    # Find project root
    local project_root
    if ! project_root=$(find_project_root); then
        log_error "Not in an NX workspace (no nx.json found)"
        echo "Make sure you're in an NX project directory"
        exit 1
    fi
    
    # Load configuration
    load_config "$project_root"
    
    # Execute command
    case "$cmd" in
        stats)
            cmd_stats "$project_root"
            ;;
        apps)
            cmd_list_apps "$project_root"
            ;;
        clean)
            cmd_clean "$project_root" "false"
            ;;
        stop)
            cmd_stop
            ;;
        reset)
            cmd_reset "$project_root"
            ;;
        rotate)
            cmd_rotate "$project_root" "$rotate_app" "$max_lines" "$trim_to"
            ;;
        init)
            cmd_init "$project_root"
            ;;
        config)
            cmd_show_config "$project_root"
            ;;
        demo)
            cmd_demo "$project_root" "$demo_apps"
            ;;
        daemon)
            cmd_daemon "$project_root" "$follow" "$lines"
            ;;
        cache)
            cmd_cache "$project_root" "$follow" "$lines"
            ;;
        *)
            # Handle export mode
            if [[ -n "$export_file" ]]; then
                if [[ ${#apps[@]} -eq 0 ]]; then
                    log_error "Please specify an app to export: $SCRIPT_NAME <app> --export <file>"
                    exit 1
                fi
                local format="text"
                [[ "$json_output" == "true" ]] && format="json"
                for app in "${apps[@]}"; do
                    cmd_export "$project_root" "$app" "$export_file" "$lines" "$search" "$errors_only" "$since" "$until" "$format"
                done
            elif [[ "$view_all" == "true" ]]; then
                cmd_view_all "$project_root" "$lines" "$follow" "$errors_only"
            elif [[ ${#apps[@]} -gt 0 ]]; then
                for app in "${apps[@]}"; do
                    if [[ "$json_output" == "true" ]]; then
                        cmd_view_json "$project_root" "$app" "$lines" "$search" "$errors_only" "$since" "$until"
                    else
                        cmd_view "$project_root" "$app" "$lines" "$follow" "$search" "$errors_only" "$since" "$until"
                    fi
                done
            else
                cmd_interactive "$project_root"
            fi
            ;;
    esac
}

main "$@"
